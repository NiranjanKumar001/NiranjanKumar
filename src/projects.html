<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Projects - Niranjan Kumar</title>
  <link rel="stylesheet" href="/public/projects.css">
  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  <style>
    /* Navigation specific styles */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      padding: 1em;
      display: flex;
      gap: 2em;
      z-index: 100;
      background-color: transparent;
    }

    .nav-logo {
      flex: 1 1 100%;
      text-align: center;
    }

    .nav-logo a {
      font-family: "Druk", sans-serif;
      font-size: 1.75rem;
      font-weight: bolder;
      font-style: italic;
      line-height: 0.9;
      color: #fff;
      text-decoration: none;
    }

    .nav-link {
      color: #fff;
      text-decoration: none;
      font-family: "Akkurat Mono", monospace;
      font-size: 0.7rem;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .nav-link:hover {
      color: #ff6b00;
    }

    .nav-link.active {
      color: #ff6b00;
    }

    .nav-link .nav-icon {
      display: none;
    }
    .nav-link .nav-text {
      display: inline;
    }

    .nav > * {
      flex: 1;
    }

    .links {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    @media (max-width: 600px) {
      .nav-link .nav-text {
        display: none;
      }
      .nav-link .nav-icon {
        display: inline-block;
        color: #fff;
      }
      .links {
        justify-content: center;
        gap: 1.5em;
      }
      .nav-logo {
        flex: 1 1 100%;
        text-align: center;
      }
      .nav {
        gap: 0;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <nav class="nav">
      <div class="links">
        <a href="/src/services.html" class="nav-link nav-services">
          <span class="nav-text">Services</span>
          <span class="nav-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="7" width="18" height="13" rx="2"/><path d="M16 3v4"/><path d="M8 3v4"/></svg>
          </span>
        </a>
        <a href="/src/projects.html" class="nav-link nav-projects active">
          <span class="nav-text">Projects</span>
          <span class="nav-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 22 7 12 12 2 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>
          </span>
        </a>
      </div>
      <div class="nav-logo">
        <a href="/index.html">NIRANJAN<br />KUMAR</a>
      </div>
      <div class="links">
        <a href="/src/about.html" class="nav-link nav-about">
          <span class="nav-text">About</span>
          <span class="nav-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M2 20c0-4 8-6 10-6s10 2 10 6"/></svg>
          </span>
        </a>
        <a href="/src/contact.html" class="nav-link nav-contact">
          <span class="nav-text">Contact</span>
          <span class="nav-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><polyline points="2,4 12,14 22,4"/></svg>
          </span>
        </a>
      </div>
    </nav>

    <section class="hero">
      <h1>
        <span>Enter a Universe</span>
        Powered by Imagination and Creativity
      </h1>
    </section>
    <section class="sticky">
      <div class="bg-img">
        <img src="/public/img18.jpg" alt="" />
      </div>
      <canvas class="outline-layer"></canvas>

      <div class="cards">
        <div class="card">
          <div class="card-img"><img src="/public/p1.png" alt="" /></div>
          <div class="card-title">
            <h1>Fabrion</h1>
            <p>Website Builder</p>
          </div>
        </div>
        <div class="card">
          <div class="card-img"><img src="/public/p2.png" alt="" /></div>
          <div class="card-title">
            <h1>Go Prakritik</h1>
            <p>E-Commerce Website</p>
          </div>
        </div>
        <div class="card">
          <div class="card-img"><img src="/public/p3.png" alt="" /></div>
          <div class="card-title">
            <h1>Cre-Avant</h1>
            <p>STARTUP Pitch Website</p>
          </div>
        </div>
        <div class="card">
          <div class="card-img"><img src="/public/p4.png" alt="" /></div>
          <div class="card-title">
            <h1>Iphone 16 Pro</h1>
            <p>First Clone</p>
          </div>
        </div>
        <div class="card">
          <div class="card-img"><img src="/public/p5.png" alt="" /></div>
          <div class="card-title">
            <h1>TechNexus</h1>
            <p>Hackathon Finder</p>
          </div>
        </div>
      </div>

      <canvas class="fill-layer"></canvas>
    </section>
    <section class="outro">
      <h1> chase the <span>shadows</span> to embrace the light</h1>
    </section>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Register the ScrollTrigger plugin
      gsap.registerPlugin(ScrollTrigger);

      // Create a simple smooth scroll implementation (no Lenis dependency)
      let currentScroll = window.scrollY;
      let targetScroll = window.scrollY;
      let scrollEase = 0.1;
      
      // Simple smooth scroll logic
      function smoothScroll() {
        currentScroll = currentScroll + (targetScroll - currentScroll) * scrollEase;
        
        // Trigger ScrollTrigger update
        ScrollTrigger.update();
        
        // Request next frame
        requestAnimationFrame(smoothScroll);
      }
      
      // Start smooth scroll animation
      smoothScroll();
      
      // Update targetScroll on window scroll
      window.addEventListener('scroll', () => {
        targetScroll = window.scrollY;
      });

      const stickySection = document.querySelector(".sticky");
      const stickyHeight = window.innerHeight * 5;
      const outlineCanvas = document.querySelector(".outline-layer");
      const fillCanvas = document.querySelector(".fill-layer");
      const outlineCtx = outlineCanvas.getContext("2d");
      const fillCtx = fillCanvas.getContext("2d");

      function setCanvasSize(canvas, ctx) {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 0.3*window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.scale(dpr, dpr);
      }

      setCanvasSize(outlineCanvas, outlineCtx);
      setCanvasSize(fillCanvas, fillCtx);

      const triangleSize = 50;
      const lineWidth = 1;
      const SCALE_THRESHOLD = 0.01;
      let triangleStates = [];
      let animationFrameId = null;
      let canvasXPosition = 0;

      function drawTriangle(ctx, x, y, fillScale = 0, flipped = false) {
        const halfSize = triangleSize / 2;

        // Draw outline triangle
        if (fillScale < SCALE_THRESHOLD) {
          ctx.beginPath();
          if (!flipped) {
            ctx.moveTo(x, y - halfSize);
            ctx.lineTo(x + halfSize, y + halfSize);
            ctx.lineTo(x - halfSize, y + halfSize);
          } else {
            ctx.moveTo(x, y + halfSize);
            ctx.lineTo(x + halfSize, y - halfSize);
            ctx.lineTo(x - halfSize, y - halfSize);
          }
          ctx.closePath();
          ctx.strokeStyle = "rgba(255, 255, 255, 0.075)";
          ctx.lineWidth = lineWidth;
          ctx.stroke();
        }

        // Draw filled triangle
        if (fillScale >= SCALE_THRESHOLD) {
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(fillScale, fillScale);
          ctx.translate(-x, -y);

          ctx.beginPath();
          if (!flipped) {
            ctx.moveTo(x, y - halfSize);
            ctx.lineTo(x + halfSize, y + halfSize);
            ctx.lineTo(x - halfSize, y + halfSize);
          } else {
            ctx.moveTo(x, y + halfSize);
            ctx.lineTo(x + halfSize, y - halfSize);
            ctx.lineTo(x - halfSize, y - halfSize);
          }
          ctx.closePath();
          ctx.fillStyle = "#ff6b00";
          ctx.strokeStyle = "#ff6b00";
          ctx.lineWidth = lineWidth;
          ctx.stroke();
          ctx.fill();
          ctx.restore();
        }
      }

      function drawGrid(scrollProgress = 0) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
        fillCtx.clearRect(0, 0, fillCanvas.width, fillCanvas.height);

        const animationProgress = scrollProgress <= 0.65 ? 0 : (scrollProgress - 0.65) / 0.35;

        let needsUpdate = false;
        const animationSpeed = 0.15;

        // Draw outline triangles
        triangleStates.forEach((state) => {
          if (state.scale < 1) {
            const x = state.col * (triangleSize * 0.5) + triangleSize / 2 + canvasXPosition;
            const y = state.row * triangleSize + triangleSize / 2;
            const flipped = (state.row + state.col) % 2 !== 0;
            drawTriangle(outlineCtx, x, y, 0, flipped);
          }
        });

        // Draw filled triangles with animation
        triangleStates.forEach((state) => {
          const shouldBeVisible = state.order / triangleStates.length <= animationProgress;
          const targetScale = shouldBeVisible ? 1 : 0;
          const newScale = state.scale + (targetScale - state.scale) * animationSpeed;

          if (Math.abs(newScale - state.scale) > 0.001) {
            state.scale = newScale;
            needsUpdate = true;
          }

          if (state.scale >= SCALE_THRESHOLD) {
            const x = state.col * (triangleSize * 0.5) + triangleSize / 2 + canvasXPosition;
            const y = state.row * triangleSize + triangleSize / 2;
            const flipped = (state.row + state.col) % 2 !== 0;
            drawTriangle(fillCtx, x, y, state.scale, flipped);
          }
        });

        if (needsUpdate) {
          animationFrameId = requestAnimationFrame(() => drawGrid(scrollProgress));
        }
      }

      function initializeTriangles() {
        const cols = Math.floor(window.innerWidth / triangleSize) + 1;
        const rows = Math.floor(window.innerHeight / triangleSize) * 2;

        // Create all possible positions
        let positions = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            positions.push({ row, col });
          }
        }

        // Shuffle positions array
        for (let i = positions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [positions[i], positions[j]] = [positions[j], positions[i]];
        }

        // Create triangle states
        triangleStates = positions.map((pos, index) => ({
          row: pos.row,
          col: pos.col,
          scale: 0,
          order: index
        }));
      }

      // Initialize and draw on load
      initializeTriangles();
      drawGrid();

      // Handle window resize
      window.addEventListener("resize", () => {
        initializeTriangles();
        drawGrid();
      });

      ScrollTrigger.create({
        trigger: stickySection,
        start: "top top",
        end: `+=${stickyHeight}px`,
        pin: true,
        onUpdate: (self) => {
          canvasXPosition = -self.progress * 200;
          drawGrid(self.progress);

          const cards = document.querySelector(".cards");
          const progress = Math.min(self.progress / 0.654, 1);
          gsap.set(cards, {
            x: -progress * window.innerWidth * 2,
          });
        },
      });
    });
  </script>
</body>
</html>